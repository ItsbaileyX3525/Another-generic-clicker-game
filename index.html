<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGCG</title>
</head>

<body style="background-color: black;">
<script>
let saveVersion = 1.1

function clickSound(vol = .4) {
    let click = new Audio('/assets/Click.mp3')
    click.play()
    click.volume = vol
    click.addEventListener('ended', () => {
        click.pause()
        click = null
    })
}

let backgroundMusic = new Audio('/assets/DanTDM - Spacedog.mp3')
backgroundMusic.volume = .4

let achievementEarnSound = new Audio('/assets/AchievementGot.mp3')
achievementEarnSound.volume = .4
let achievementEarnSoundBetter = new Audio('/assets/AchievementGotBest.mp3')
achievementEarnSoundBetter.volume = .4

let saveGameSFX = new Audio('/assets/save.mp3')
let purchaseUpgradeSFX = new Audio('/assets/purchase.mp3')
let purchaseUpgradeFailSFX = new Audio('/assets/purchaseFail.mp3')

// Format large numbers to human-readable form (e.g., 1.2k, 3.4M) with up to 1 decimal place.
function formatNumber(value) {
    if (value === null || value === undefined) return '0';
    const num = Number(value);
    if (!isFinite(num)) return '0';
    if (Math.abs(num) < 1000) return num.toString();
    const units = ['', 'k', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc'];
    let unitIndex = 0;
    let scaled = num;
    while (Math.abs(scaled) >= 1000 && unitIndex < units.length - 1) {
        scaled /= 1000;
        unitIndex++;
    }
    let str = scaled.toFixed(1);
    if (str.endsWith('.0')) str = str.slice(0, -2);
    return str + units[unitIndex];
}
window.formatNumber = formatNumber;

class GameLogic {
    constructor(data) {
        this.firstLoadClicks = true
        this.firstLoadScore = true
        if (data) {
            data = JSON.parse(data)
            this.saveVersion = parseFloat(data["saveVersion"],10)
            if (this.saveVersion === saveVersion) {
                print("Game save up to date... yea good job")
            } else {
                print("Alert alert user data out of date, attempted to migrate... not atm tho (not implemented)")
                warningText.enabled = true
            }
            this.milestones = data["milestones"]
            this.achievements = data["achievements"]
            this.upgrades = data["upgrades"]
            this.totalScore = parseInt(data["totalScore"],10)
            this.score = parseInt(data["score"],10);
            this.clicks = parseInt(data["clicks"],10)
            this.generatorData = data["generatorData"] || {}
            this.generateAmount = 0
            for (let value of Object.values(this.generatorData)) {
                //value structure: [amount bought, price, total earn]
                this.generateAmount += value[2]
            }
            if (!window._genIntervalSet) {
                window._genIntervalSet = true
                setInterval(() => {
                    this.generateScore();
                }, 1000);
            }
            if (!window._saveIntervalSet) {
                window._saveIntervalSet = true
                setInterval(() => this.saveGame(), 2500);
            }
            console.log('[GameLogic] Loaded. generateAmount =', this.generateAmount, 'generatorData =', this.generatorData)
        } else { //First time playing or they deleted their data or summin
            this.milestones = {
                "achieved50Clicks" : false,
            }
            this.saveVersion = 1.1
            this.upgrades = {}
            this.score = 0
            this.generateAmount = 0
            this.clicks = 0
            this.totalScore = 0
            this.generatorData = {}
            this.achievements = {
                "idkJustRandomPlaceHolder" : false,
            }
            if (!window._genIntervalSet) {
                window._genIntervalSet = true
                setInterval(() => this.generateScore(), 1000);
            }
            if (!window._saveIntervalSet) {
                window._saveIntervalSet = true
                setInterval(() => this.saveGame(), 2500);
            }
            console.log('[GameLogic] Fresh start.') //<--- How sigma does this look
        }

    }

    get clicks() {
        return this._clicks
    }

    set clicks(newval) {
        this._clicks = parseInt(newval,10)
        if (this.firstLoadClicks) {this.firstLoadClicks=false;return}
        //Game upgrades
        if (this.clicks >= 10 && !this.milestones["achieved10Clicks"]) {
            this.milestones["achieved10Clicks"] = true
            window.clicks10()
        }
        if (this.clicks >= 50 && !this.milestones["achieved50Clicks"]) {
            this.milestones["achieved50Clicks"] = true
            window.clicks50()
        }
        if (this.clicks >= 100 && !this.milestones["achieved100Clicks"]) {
            this.milestones["achieved100Clicks"] = true
            window.clicks100()
        }
        if (this.clicks >= 225 && !this.milestones["achieved225Clicks"]) {
            this.milestones["achieved225Clicks"] = true
            window.clicks225()
        }
        if (this.clicks >= 350 && !this.milestones["achieved350Clicks"]) {
            this.milestones["achieved350Clicks"] = true
            window.clicks350()
        }
        if (this.clicks >= 500 && !this.milestones["achieved500Clicks"]) {
            this.milestones["achieved500Clicks"] = true
            window.clicks500()
        }


        //Achievements
        print(this.clicks)
        print(!this.achievements["firstClick"])
        if (this.clicks >= 1 && !this.achievements["firstClick"]) {
            print("Showing achievement")
            this.achievements["firstClick"] = true
            window.displayAchievement('Getting started!', false)
        }
    }

    get score() {
        return this._score;
    }

    set score(newval) {
        this._score = parseInt(newval,10)
        if (this.firstLoadScore) {this.firstLoadScore=false;return}
        this.totalScore += newval
        if (this.score >= 150 && !this.milestones["achieved150Score"]) {
            this.milestones["achieved150Score"] = true
            window.score150()
        }
        if (this.score >= 500 && !this.milestones["achieved500Score"]) {
            this.milestones["achieved500Score"] = true
            window.score500()
        }
        if (this.score >= 800 && !this.milestones["achieved800Score"]) {
            this.milestones["achieved800Score"] = true
            window.score800()
        }
        if (this.score >= 1200 && !this.milestones["achieved1200Score"]) {
            this.milestones["achieved1200Score"] = true
            window.score1200()
        }
        
    }

    get generateAmount() {
        return this._generateAmount
    }

    set generateAmount(newval) {
        this._generateAmount = newval
    }

    purchaseUpgrade = (upgrade, el) => {
        if (this.score >= parseInt(this.upgrades[upgrade][0],10)) {
            this.upgrades[upgrade][1] = true
            this.score -= parseInt(this.upgrades[upgrade][0],10)
            
            activeUpgrades.shift()
            
            removeHover(el)
            destroy(el)
            
            if (storedUpgrades.length >= 1) {
                addUpgrade(storedUpgrades[0][0], storedUpgrades[0][1], storedUpgrades[0][2], true)
                storedUpgrades.shift()
            }
            
            loadUpgrades()
            purchaseUpgradeSFX.play()
            
            if (storedUpgrades.length == 0) {
                nextUpgrade.enabled = false
            } else {
                nextUpgrade.enabled = true
            }
            return true
        } else {
            purchaseUpgradeFailSFX.play()
            return false
        }
    }

    buyGen(gen, genPrice, genEarn, genName) {
        if (this.score >= genPrice) {
            //Success
            this.score -= genPrice;

            const newPrice = Math.floor(genPrice * 1.25);
            gen.cost = newPrice;

            this.generateAmount += genEarn;

            if (!this.generatorData[genName]) {
                this.generatorData[genName] = [0, 0, 0]; // [amount bought, current price, total earn]
            }
            this.generatorData[genName][0] += 1; // amount bought
            this.generatorData[genName][1] = newPrice; // store updated price
            this.generatorData[genName][2] += genEarn; // cumulative earn per second contributed

            gen.text = `Generate ${formatNumber(genEarn)} clicks a second\nCost: ${formatNumber(newPrice)} clicks`;
            return true;
        } else {
            print("Broke boy");
            //Failure sound effect
            return false;
        }
    }

    addScore = (newScore) => {
        this.score += newScore
    }

    generateScore = () => {
        this.addScore(this.generateAmount)
    }

    saveGame = () => {
        const save = {
            "score": this.score,
            "generateAmount": this.generateAmount,
            "clicks" : this.clicks,
            "milestones" : this.milestones,
            "upgrades" : this.upgrades,
            "totalScore" : this.totalScore,
            "generatorData" : this.generatorData,
            "saveVersion" : this.saveVersion,
            "achievements" : this.achievements,
        }
        localStorage.setItem('gameData', JSON.stringify(save))
    }
}

const data = localStorage.getItem('gameData') || null


function onEnter(el, description, cost, event) {
    mouseTooltip.text = description + "\n<center>Cost: " + formatNumber(cost) + "</center>";
    mouseTooltip.enabled = true;
}

function onLeave(event) {
	mouseTooltip.text = "";
	mouseTooltip.enabled = false;
}

function addHover(el, description, cost) {
	console.log("Added hover");

    el._boundEnter = onEnter.bind(null, el, description, cost);
	el._boundLeave = onLeave.bind(null);

	el.addEventListener('mouseenter', el._boundEnter);
	el.addEventListener('mouseleave', el._boundLeave);
}

function removeHover(el) {
	mouseTooltip.text = "";
	mouseTooltip.enabled = false;

	if (el._boundEnter) {
		el.removeEventListener('mouseenter', el._boundEnter);
		delete el._boundEnter;
	}

	if (el._boundLeave) {
		el.removeEventListener('mouseleave', el._boundLeave);
		delete el._boundLeave;
	}
}

function getPerformance() {
    return performance.now()
}

function getDelta() {
    calc = getPerformance() - lastTime
	delta = calc / 1000
	lastTime = getPerformance()
    return delta
}

</script>
<script src="/taptapir/taptapir.js">
</script>
<script type="text/sunsnake">

set_orientation('horizontal')
print("Hello world")
set_window_color('rgb(23,23,23)')
ASSETS_FOLDER = '/assets/'

startScreenElements = []
infoScreenElements = []
mainGameElements = []
generatorElements = []
activeUpgrades = []
storedUpgrades = []

######## Main menu stuff ############

def loadScreen(name): #Debuggin
    for e in startScreenElements:
        e.enabled = false
    if name == "info":
        for e in infoScreenElements:
            e.enabled = true
    if name == "game":
        for e in startScreenElements:
            e.enabled = false
        after .01:
            for e in mainGameElements:
                e.enabled = true
                backgroundMusic.play()
        
        activeUpgrades = []
        storedUpgrades = []
        
        for ([key, value] of Object.entries(game.upgrades)) {

                if not value[1]:
                    addUpgrade(key, value[2], value[0])        
        
        loadUpgrades()
        loadGenerators()

gameTitle = Text(text = 'Another generic clicker game',y=.4, text_color = color.white)
gameTitle.fit_to_text()
gameStart = Button(text = 'START GAME', text_color=color.white, color=color.black, scale_y=.2,scale_x = .5)
gameStart.on_click = def():
    gameStart.animate('scale_x', .4, duration=.03)
    gameStart.animate('scale_y', .18, duration=.03)
    after .2:
        gameStart.animate('scale_x', .5, duration=.05)
        gameStart.animate('scale_y', .2, duration=.05)
        for e in startScreenElements:
            e.enabled = false
        after .01:
            for e in mainGameElements:
                e.enabled = true
                backgroundMusic.play()
        
        activeUpgrades = []
        storedUpgrades = []
        
        for ([key, value] of Object.entries(game.upgrades)) {

                if not value[1]:
                    addUpgrade(key, value[2], value[0])        
        
        loadUpgrades()
        loadGenerators()

warningText = Text(enabled=false,text_size=1.8,y=.3,x=.084,text='Your save is outdated and may cause errors, it is\nrecommended that you erase your save to continue playing.', text_color=color.red)
warningText.fit_to_text()

erasedText = Text(enabled=false,text='Data erased successfully!',y=.3, text_color=color.red)
erasedText.fit_to_text()

if localStorage.getItem('erased') == 'true':
    localStorage.setItem('erased', 'false')
    erasedText.enabled = true

eraseData = Button(text='Erase save',padding=.3,text_size=2.5,y=-.22)
eraseData.fit_to_text()
eraseData.on_click = def():
    localStorage.clear()
    localStorage.setItem('erased', 'true')
    window.location.reload()

infoButton = Button(text = 'What game engine is this?',padding=1, scale_x = .4, scale_y = .1, text_size = 1.6, y=-.4, text_color = color.light_gray, color=color.dark_gray)
infoButton.fit_to_text()
infoButton.on_click = def():
    for e in startScreenElements:
        e.enabled = false 
    for e in infoScreenElements:
        e.enabled = true

infoScreenBG = Entity(color=color.light_gray, scale_x=2, scale_y=2, enabled = false)
infoText = Text(y=.3,x=0,text = 'The game engine is called taptapir, it is a game engine that was created by <a style="color: salmon;" target="_blank" href="https://github.com/pokepetter/">Pokepetter</a>\nPokepetter created the taptapir engine as a method for building mobile games in a way\nthat felt like you were still using ursina\n\nFor that reason I fell in love with taptapir and used it in my early development life as I\ndidn\'t know any other methods to build for mobile at the time (I was a new dev)\nso thank you Poke for creating taptapir', enabled = false, text_size=2, enabled = false)
infoText.fit_to_text()
infoReturn = Button(text = 'RETURN', scale_x=.5, scale_y=.15, y=-.19, enabled = false)
infoReturn.on_click = def():
    for e in startScreenElements:
        e.enabled = true
    for e in infoScreenElements:
        e.enabled = false

startScreenElements.append(gameTitle)
startScreenElements.append(gameStart)
startScreenElements.append(infoButton)
startScreenElements.append(eraseData)
startScreenElements.append(erasedText)

infoScreenElements.append(infoText)
infoScreenElements.append(infoScreenBG)
infoScreenElements.append(infoReturn)


########## Clicker game stuff ###########

def clicks10():
    game.upgrades["scoreDisplay"] = [10, false, "See how much clicks you have"]
    addUpgrade("scoreDisplay", game.upgrades["scoreDisplay"][2], game.upgrades["scoreDisplay"][0])

def clicks50():
    game.upgrades["clickAnim"] = [50, false, "Add a cool click animation"]
    addUpgrade("clickAnim", game.upgrades["clickAnim"][2], game.upgrades["clickAnim"][0])

def clicks100():
    game.upgrades["clickEffects"] = [199, false, "Make some particles appear!"]
    addUpgrade("clickEffects", game.upgrades["clickEffects"][2], game.upgrades["clickEffects"][0])
          
def clicks225():
    game.upgrades["clickCrit"] = [425, false, "Unlock critical clicks!"]
    addUpgrade("clickCrit", game.upgrades["clickCrit"][2], game.upgrades["clickCrit"][0])

def clicks350():
    game.upgrades["autoClicker"] = [900, false, "Be lazy, auto click!"]
    addUpgrade("autoClicker", game.upgrades["autoClicker"][2], game.upgrades["autoClicker"][0])

def clicks500():
    game.upgrades["clickPower"] = [5000, false, "Increase your click power tenfold!"]
    addUpgrade("clickPower", game.upgrades["clickPower"][2], game.upgrades["clickPower"][0])

def score150():
    game.upgrades["generators"] = [250, false, "Unlock some automation"]
    addUpgrade("generators", game.upgrades["generators"][2], game.upgrades["generators"][0])

def score500():
    game.upgrades["save"] = [750, false, "Save your game whenever\nyou want!"]
    addUpgrade("save", game.upgrades["save"][2], game.upgrades["save"][0])

def score800():
    game.upgrades["background"] = [1000, false, "Add a nice background to\nthe game"]
    addUpgrade("background", game.upgrades["background"][2], game.upgrades["background"][0])

def score1200():
    game.upgrades["removeBackground"] = [1500, false, "Create a button to turn\noff the background!"]
    addUpgrade("removeBackground", game.upgrades["removeBackground"][2], game.upgrades["removeBackground"][0])


def loadUpgrades():
    if game.upgrades["scoreDisplay"] and game.upgrades["scoreDisplay"][1]:
        scoreText.enabled = true
        mainGameElements.append(scoreText)
    if game.upgrades["save"] and game.upgrades["save"][1]:
        saveGameButton.enabled = true
        mainGameElements.append(saveGameButton)
    if game.upgrades["generators"] and game.upgrades["generators"][1]:
        generatorButton.enabled = true
        mainGameElements.append(generatorButton)
    if game.upgrades['background'] and game.upgrades['background'][1]:
        if localStorage.getItem('backgroundEnabled') === 'true' or localStorage.getItem('backgroundEnabled') === null:
            background.enabled = true
        localStorage.setItem('backgroundEnabled', 'true')
        mainGameElements.append(background)
    if game.upgrades['removeBackground'] and game.upgrades['removeBackground'][1]:
        backgroundToggle.enabled = true
        if localStorage.getItem('backgroundEnabled') === 'true' or localStorage.getItem('backgroundEnabled') === null:
            backgroundToggle.texture = 'bgEnabled.svg'
        else:
            backgroundToggle.texture = 'bgDisabled.svg'
        backgroundToggle.color = color.gray
        mainGameElements.append(backgroundToggle)
    if game.upgrades['autoClicker'] and game.upgrades['autoClicker'][1]:
        autoClicker.enabled = true

def addUpgrade(upgrade, description, cost, skipDuplicateCheck = false):
    if not skipDuplicateCheck:
        for activeUpg in activeUpgrades:
            if activeUpg.text == upgrade:
                return
        
        for storedUpg in storedUpgrades:
            if storedUpg[0] == upgrade:
                return
    
    if activeUpgrades.length >= 1:
        upgradeData = [upgrade, description, cost]
        storedUpgrades.append(upgradeData)
        nextUpgrade.enabled = true
        return
    
    for e in activeUpgrades:
        e.x-=.13 
    b = Button(parent=upgradeHolder,text=upgrade,name="upgradeButton",price=cost, text_size=1.3, color=color.black, text_color=color.white, scale=.125,y=-.11,x=0,desc=description)
    b.on_click = def():
        game.purchaseUpgrade(upgrade, b)
    addHover(b.el,description,cost)
    activeUpgrades.append(b)
    
    if storedUpgrades.length > 0:
        nextUpgrade.enabled = true
    else:
        nextUpgrade.enabled = false

mouseTooltip = Text(enabled = false, text_color=color.white,text = 'description of what\nthe button does\n<center>Cost: 50</center>', text_size=2, color=color.black)
mouseTooltip.fit_to_text()
mouseTooltip.update = def():
    mouseTooltip.x = mouse.x +.25
    mouseTooltip.y = mouse.y +.08
    mouseTooltip.fit_to_text()

saveGameButton = Button(texture = 'save.svg', y=.3, scale = .12, color=color.gray, y=.43,x=.8, enabled=false)
saveGameButton.on_click = def():
    if not saveGameButton.disabled:
        saveGameButton.disabled = true
        game.saveGame()
        saveGameSFX.currentTime = 0
        saveGameSFX.play()
        after .6:
            saveGameButton.disabled = false
        
        t = Text(text='Game saved successfully', text_color=color.green,y=-.44,x=.02)
        t.fit_to_text()
        t.animate("y", -.32, duartion=.4)

        after .6:
            destroy(t)

scoreText = Text(text = 'Clicks: 0', text_color=color.light_gray, y=.43, enabled=false)
scoreText.fit_to_text()
scoreText.update = def():
    scoreText.text = 'Clicks: ' + formatNumber(game.score)

minParticleX = .2
maxParticleX = .5

def destroyParticle(particle):
    after 1:
        destroy(particle)

def showParticle(amount, isCrit):
    colorShown = color.yellow
    if isCrit:
        colorShown = color.orange
    xPos = Math.random() * (maxParticleX - minParticleX) + minParticleX
    particle = Text(text = '+' + String(amount), text_color=colorShown,y=-.25,x=xPos)
    particle.animate('y', -.1, duration = 2, curve=curves.out_expo)
    destroyParticle(particle)

prevClickAmount = parseInt(localStorage.getItem('clickAmount'), 10) || 0

clickToEarn = Button(y=.07,enabled = false)  
clickToEarn.on_click = def():
    clickSound()
    randChance = 0
    multiplier = 1
    amount = 0
    isCrit = false
    if Object.hasOwn(game.upgrades, "clickCrit") and game.upgrades["clickCrit"][1]:
        randChance = Math.floor(Math.random() * 15) + 1
        if randChance == 15:
            multiplier = 4
            isCrit = true
    if Object.hasOwn(game.upgrades, "clickAnim") and game.upgrades["clickAnim"][1]:
        clickToEarn.scale=.22
        clickToEarn.animate('scale_x', .2, duration=.1)
        clickToEarn.animate('scale_y', .2, duration=.1)
        if Object.hasOwn(game.upgrades, "clickPower") and game.upgrades["clickPower"][1]:
            localStorage.setItem('clickAmount', 20)
            prevClickAmount = 20
            amount = 20 * multiplier
            game.score += amount
        else:
            localStorage.setItem('clickAmount', 2)
            prevClickAmount = 2
            amount = 2 * multiplier
            game.score += amount
    else:
        localStorage.setItem('clickAmount', 1)
        prevClickAmount = 1
        amount = 1 * multiplier
        game.score += amount

    
    game.clicks += 1

    if Object.hasOwn(game.upgrades, "clickEffects") and game.upgrades["clickEffects"][1]:
        showParticle(amount, isCrit)


#Shocking how hard this was to make
autoClickerMaxX = -.146
autoClickerMinX =  -.19
autoClickInterval = 1.0 / 3.5
autoClickTimer = 0

lastTime = getPerformance();
delta = 0
calc = 0

def click():
    autoClicker.animate("x", autoClickerMaxX, duration = autoClickInterval/2, curve=curves.in_out_expo)
    multiplier = 1
    isCrit = false
    if Object.hasOwn(game.upgrades, "clickCrit") and game.upgrades["clickCrit"][1]:
        randChance = Math.floor(Math.random() * 15) + 1
        if randChance == 15:
            multiplier = 4
            isCrit = true
    after autoClickInterval/2:
        clickSound(.1)
        game.clicks += .2 //Because I'm evil
        if prevClickAmount === 0:
            prevClickAmount = 1
        amount = prevClickAmount * multiplier
        game.score += amount
        if Object.hasOwn(game.upgrades, "clickEffects") and game.upgrades["clickEffects"][1]:
            showParticle(amount, isCrit)

        autoClicker.animate("x", autoClickerMinX, duration = autoClickInterval/2, curve=curves.in_out_expo)

autoClicker = Entity(enabled=false,parent=camera.ui,texture='cursorClick.svg',scale=.1, x=-.19,y=.05,rotation=90)
autoClicker.update = def():
    if autoClicker.enabled:
        delta = getDelta()

        autoClickTimer += delta
        if autoClickTimer >= autoClickInterval:
            click()
            autoClickTimer = 0


upgradeHolder = Entity(parent=camera.ui, color=color.clear)

nextUpgrade = Button(parent=upgradeHolder,enabled=false,text = '>', y=-.11,x=.12, padding=.27,text_size=2.6)
nextUpgrade.fit_to_text()
nextUpgrade.on_click = def():
    if len(storedUpgrades) >= 1:
        if len(activeUpgrades) > 0:
            currentUpgrade = activeUpgrades[0]
            currentUpgradeData = [currentUpgrade.text, currentUpgrade.desc, currentUpgrade.price]
            storedUpgrades.append(currentUpgradeData)
            
            removeHover(currentUpgrade)
            destroy(currentUpgrade)
            activeUpgrades.shift()
        
        nextUpgradeData = storedUpgrades[0]
        storedUpgrades.shift()
        
        addUpgrade(nextUpgradeData[0], nextUpgradeData[1], nextUpgradeData[2], true)
        
        nextUpgrade.enabled = true

generatorButton = Button(text = "Generators", x=.67, padding=.6, text_color=color.white, color=color.black, enabled = false)
generatorButton.on_click = def():
    for e in mainGameElements:
        e.enabled = false
    for e in generatorElements:
        e.enabled = true

generatorButton.fit_to_text()

backgroundToggle = Button(scale=.15,enabled=false,texture='bgEnabled.svg',color=color.gray, y=.41,x=-.8)
backgroundToggle.on_click = def():
    background.enabled = not background.enabled
    localStorage.setItem('backgroundEnabled', background.enabled)
    if background.enabled:
        backgroundToggle.texture = 'bgEnabled.svg'
    else:
        backgroundToggle.texture = 'bgDisabled.svg'
    backgroundToggle.color = color.gray

mainGameElements.append(clickToEarn)
mainGameElements.append(upgradeHolder)

###### Generators ######

def loadGenerators():
    if game.generatorData["gen1"]:
        gen1.cost = game.generatorData["gen1"][1]
    gen1.text = "Generate " + formatNumber(5) + " clicks a second\nCost: " + formatNumber(gen1.cost) + " clicks"
    if game.generatorData["gen2"]:
        gen2.cost = game.generatorData["gen2"][1]
    gen2.text = "Generate " + formatNumber(18) + " clicks a second\nCost: " + formatNumber(gen2.cost) + " clicks"
    if game.generatorData["gen3"]:
        gen3.cost = game.generatorData["gen3"][1]
    gen3.text = "Generate " + formatNumber(70) + " clicks a second\nCost: " + formatNumber(gen3.cost) + " clicks"
    if game.generatorData["gen4"]:
        gen4.cost = game.generatorData["gen4"][1]
    gen4.text = "Generate " + formatNumber(260) + " clicks a second\nCost: " + formatNumber(gen4.cost) + " clicks"
    if game.generatorData["gen5"]:
        gen5.cost = game.generatorData["gen5"][1]
    gen5.text = "Generate " + formatNumber(950) + " clicks a second\nCost: " + formatNumber(gen5.cost) + " clicks"
    if game.generatorData["gen6"]:
        gen6.cost = game.generatorData["gen6"][1]
    gen6.text = "Generate " + formatNumber(3300) + " clicks a second\nCost: " + formatNumber(gen6.cost) + " clicks"

exitGenerator = Button(text = 'RETURN', position=top_left, padding=.2, enabled = false)
exitGenerator.y-=.05
exitGenerator.x+=.15
exitGenerator.fit_to_text()
exitGenerator.on_click = def():
    for e in generatorElements:
        e.enabled = false
    for e in mainGameElements:
        e.enabled = true
    

    if localStorage.getItem('backgroundEnabled') === 'true':
        backgroundToggle.svg = 'bgEnabled.svg'
        background.enabled = true
    else:
        backgroundToggle.svg = 'bgDisabled.svg'
        background.enabled = false

gen1 = Button(name="gen1",cost=75,genAmount=5,text_size=1,position=left,padding=.4,enabled=false,text = "Generate " + formatNumber(5) + " clicks a second\nCost: " + formatNumber(75) + " clicks")
gen1.x+=.17
gen1.y+=.28
gen1.on_click = def():
    game.buyGen(gen1,gen1.cost, gen1.genAmount, gen1.name)
gen1.fit_to_text()

gen2 = Button(name="gen2",cost=1200,genAmount=18,text_size=1,position=left,padding=.4,enabled=false,text = "Generate " + formatNumber(18) + " clicks a second\nCost: " + formatNumber(1200) + " clicks")
gen2.x+=.17
gen2.y+=.15
gen2.on_click = def():
    game.buyGen(gen2,gen2.cost, gen2.genAmount, gen2.name)
gen2.fit_to_text()

gen3 = Button(name="gen3",cost=7500,genAmount=70,text_size=1,position=left,padding=.4,enabled=false,text = "Generate " + formatNumber(70) + " clicks a second\nCost: " + formatNumber(7500) + " clicks")
gen3.x+=.17
gen3.on_click = def():
    game.buyGen(gen3,gen3.cost, gen3.genAmount, gen3.name)
gen3.fit_to_text()

gen4 = Button(name="gen4",cost=40000,genAmount=260,text_size=1,position=left,padding=.4,enabled=false,text = "Generate " + formatNumber(260) + " clicks a second\nCost: " + formatNumber(40000) + " clicks")
gen4.x+=.17
gen4.y-=.15
gen4.on_click = def():
    game.buyGen(gen4,gen4.cost, gen4.genAmount, gen4.name)
gen4.fit_to_text()

gen5 = Button(name="gen5",cost=180000,genAmount=950,text_size=1,position=left,padding=.4,enabled=false,text = "Generate " + formatNumber(950) + " clicks a second\nCost: " + formatNumber(180000) + " clicks")
gen5.x+=.17
gen5.y-=.3
gen5.on_click = def():
    game.buyGen(gen5,gen5.cost, gen5.genAmount, gen5.name)
gen5.fit_to_text()

gen6 = Button(name="gen6",cost=750000,genAmount=3300,text_size=2,padding=.4,enabled=false,text = "Generate " + formatNumber(3300) + " clicks a second\nCost: " + formatNumber(750000) + " clicks")
#gen6.x+=.8
gen6.on_click = def():
    game.buyGen(gen6,gen6.cost, gen6.genAmount, gen6.name)
gen6.fit_to_text()

generatorElements.append(scoreText)
generatorElements.append(exitGenerator)
generatorElements.append(gen1)
generatorElements.append(gen2)
generatorElements.append(gen3)
generatorElements.append(gen4)
generatorElements.append(gen5)
generatorElements.append(gen6)

######## Achievement related stuff #########

achievementFinalPosX = .64
achievementStartPosX = 1.141

activeAchievement = false
storedAchievements = []

def displayAchievement(achievementName, isCool):
    if activeAchievement:
        achievement = [achievementName, isCool]
        storedAchievements.append(achievement)
        return 

    timeout = 3
    achievementText.text = achievementName
    activeAchievement = true
    if isCool:
        achievementEarnSoundBetter.play()
        timeout = 5
    else:
        achievementEarnSound.play()

    achievementToast.animate('x', achievementFinalPosX, duration=.7)

    after timeout:
        achievementToast.animate('x', achievementStartPosX, duration=.7)
        after .75:
            activeAchievement = false

achievementToast = Entity(color=color.dark_gray,parent=camera.ui, scale=[.5,.08], x=achievementStartPosX, y=.44)
achievementToast.update = def():
    if storedAchievements.length >= 1 and not activeAchievement:
        displayAchievement(storedAchievements[0][0],storedAchievements[0][1])

achievementIcon = Entity(parent=achievementToast, texture='trophy.svg',x=-.42)
achievementEarnt = Text(parent=achievementToast,text = 'Achievement Got!',text_size=1.8,y=.3,x=-.05, text_color=color.yellow)
achievementEarnt.fit_to_text()
achievementText = Text(parent=achievementToast,text_color=color.light_gray,text='AchievementName',text_size=1.8,y=-.4,x=.08)

//displayAchievement("test achievement", true) Long version
//displayAchievement("test achievement", false) Short version

background = Entity(name="background",z=9999,enabled=false,parent=camera.ui, texture='space.jpg',scale_x=1.78, scale_y=1.01)

game = new GameLogic(data)

#loadScreen("game")
</script>
    <script src="/taptapir/sunsnake_compiler.js"></script>
</body>