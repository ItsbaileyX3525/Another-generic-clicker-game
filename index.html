<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/x-icon" href="/taptapir_logo.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGCG</title>
</head>

<body style="background-color: black;">
<script>
let saveVersion = 1.1

function clickSound(vol = .4) {
    let click = new Audio('/assets/Click.mp3')
    click.play()
    click.volume = vol
    click.addEventListener('ended', () => {
        click.pause()
        click = null
    })
}

let backgroundMusic = new Audio('/assets/DanTDM - Spacedog.mp3')
backgroundMusic.volume = .4

let achievementEarnSound = new Audio('/assets/AchievementGot.mp3')
achievementEarnSound.volume = .4
let achievementEarnSoundBetter = new Audio('/assets/AchievementGotBest.mp3')
achievementEarnSoundBetter.volume = .4

let genSpeedupSound = new Audio('/assets/speedup.mp3')
genSpeedupSound.volume = .4

let saveGameSFX = new Audio('/assets/save.mp3')
let purchaseUpgradeSFX = new Audio('/assets/purchase.mp3')
let purchaseUpgradeFailSFX = new Audio('/assets/purchaseFail.mp3')

function createVHSLines(duration = 2000) {
    // Create top scan lines
    const topLines = document.createElement('div');
    topLines.style.cssText = `
        position: fixed;
        top: 5%;
        left: 0;
        width: 100%;
        height: 80px;
        background: 
            repeating-linear-gradient(
                0deg,
                transparent 0px,
                rgba(255, 255, 255, 0.9) 1px,
                rgba(255, 255, 255, 0.6) 2px,
                transparent 3px,
                transparent 5px
            ),
            linear-gradient(
                90deg,
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.3) 50%,
                rgba(255, 255, 255, 0.1) 100%
            );
        z-index: 9999;
        pointer-events: none;
        opacity: 0.8;
        animation: vhsTracking 0.03s infinite, vhsShake 0.1s infinite;
    `;

    // Create bottom scan lines
    const bottomLines = document.createElement('div');
    bottomLines.style.cssText = `
        position: fixed;
        bottom: 5%;
        left: 0;
        width: 100%;
        height: 80px;
        background: 
            repeating-linear-gradient(
                0deg,
                transparent 0px,
                rgba(255, 255, 255, 0.9) 1px,
                rgba(255, 255, 255, 0.6) 2px,
                transparent 3px,
                transparent 5px
            ),
            linear-gradient(
                90deg,
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.3) 50%,
                rgba(255, 255, 255, 0.1) 100%
            );
        z-index: 9999;
        pointer-events: none;
        opacity: 0.8;
        animation: vhsTracking 0.03s infinite, vhsShake 0.1s infinite;
    `;

    // Create CSS animation if it doesn't exist
    if (!document.getElementById('vhs-animation-styles')) {
        const style = document.createElement('style');
        style.id = 'vhs-animation-styles';
        style.textContent = `
            @keyframes vhsTracking {
                0% { 
                    opacity: 0.8; 
                    transform: translateX(0px) scaleY(1); 
                    filter: brightness(1) contrast(1);
                }
                15% { 
                    opacity: 0.9; 
                    transform: translateX(-2px) scaleY(1.1); 
                    filter: brightness(1.2) contrast(1.3);
                }
                30% { 
                    opacity: 0.6; 
                    transform: translateX(3px) scaleY(0.9); 
                    filter: brightness(0.8) contrast(1.5);
                }
                45% { 
                    opacity: 0.9; 
                    transform: translateX(-1px) scaleY(1.2); 
                    filter: brightness(1.1) contrast(1.1);
                }
                60% { 
                    opacity: 0.7; 
                    transform: translateX(4px) scaleY(0.8); 
                    filter: brightness(1.3) contrast(1.4);
                }
                75% { 
                    opacity: 0.8; 
                    transform: translateX(-3px) scaleY(1.1); 
                    filter: brightness(0.9) contrast(1.2);
                }
                90% { 
                    opacity: 0.9; 
                    transform: translateX(2px) scaleY(1); 
                    filter: brightness(1.1) contrast(1.3);
                }
                100% { 
                    opacity: 0.8; 
                    transform: translateX(0px) scaleY(1); 
                    filter: brightness(1) contrast(1);
                }
            }
            
            @keyframes vhsShake {
                0% { transform: translateY(0px); }
                10% { transform: translateY(-1px); }
                20% { transform: translateY(1px); }
                30% { transform: translateY(-2px); }
                40% { transform: translateY(2px); }
                50% { transform: translateY(-1px); }
                60% { transform: translateY(1px); }
                70% { transform: translateY(-1px); }
                80% { transform: translateY(2px); }
                90% { transform: translateY(-1px); }
                100% { transform: translateY(0px); }
            }
        `;
        document.head.appendChild(style);
    }

    // Add elements to body
    document.body.appendChild(topLines);
    document.body.appendChild(bottomLines);

    // Remove after specified duration
    setTimeout(() => {
        if (topLines.parentNode) {
            topLines.parentNode.removeChild(topLines);
        }
        if (bottomLines.parentNode) {
            bottomLines.parentNode.removeChild(bottomLines);
        }
    }, duration);

    return {
        topLines,
        bottomLines,
        remove: () => {
            if (topLines.parentNode) topLines.parentNode.removeChild(topLines);
            if (bottomLines.parentNode) bottomLines.parentNode.removeChild(bottomLines);
        }
    };
}

// Format large numbers to human-readable form (e.g., 1.2k, 3.4M) with up to 1 decimal place.
function formatNumber(value) {
    if (value === null || value === undefined) return '0';
    const num = Number(value);
    if (!isFinite(num)) return '0';
    if (Math.abs(num) < 1000) return num.toString();
    const units = ['', 'k', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc'];
    let unitIndex = 0;
    let scaled = num;
    while (Math.abs(scaled) >= 1000 && unitIndex < units.length - 1) {
        scaled /= 1000;
        unitIndex++;
    }
    let str = scaled.toFixed(1);
    if (str.endsWith('.0')) str = str.slice(0, -2);
    return str + units[unitIndex];
}
window.formatNumber = formatNumber;

class GameLogic {
    constructor(data) {
        this.firstLoadClicks = true
        this.firstLoadScore = true
        this.achievementCounter = 5
        this.offlineAmount = 0
        if (data) {
            data = JSON.parse(data)
            this.saveVersion = parseFloat(data["saveVersion"],10)
            if (this.saveVersion === saveVersion) {
                print("Game save up to date... yea good job")
            } else {
                print("Alert alert user data out of date, attempted to migrate... not atm tho (not implemented)")
                warningText.enabled = true
            }
            this.milestones = data["milestones"]
            this.achievements = data["achievements"]
            this.upgrades = data["upgrades"]
            this.totalScore = parseInt(data["totalScore"],10)
            this.lastOnline = parseFloat(data["lastOnline"], 10)
            this.score = parseInt(data["score"],10);
            this.clicks = parseInt(data["clicks"],10)
            this.generatorData = data["generatorData"] || {}
            this.generateAmount = 0
            for (let value of Object.values(this.generatorData)) {
                //value structure: [amount bought, price, total earn]
                this.generateAmount += value[2]
            }
            if (!window._genIntervalSet) {
                window._genIntervalSet = true;
                window.genIntervalMs = window.genIntervalMs || 1000;
                window._genInterval = setInterval(() => {
                    this.generateScore();
                }, window.genIntervalMs);

                window.setGenInterval = (ms) => {
                    window.genIntervalMs = ms;
                    if (window._genInterval) clearInterval(window._genInterval);
                    window._genInterval = setInterval(() => {
                        if (window.game) {
                            window.game.generateScore();
                        }
                    }, window.genIntervalMs);
                };
            }
            if (!window._saveIntervalSet) {
                window._saveIntervalSet = true
                setInterval(() => this.saveGame(), 2500);
            }
            this.calcOfflineEarn()
        } else { //First time playing or they deleted their data or summin
            this.milestones = {
                "achieved50Clicks" : false,
            }
            this.saveVersion = 1.1
            this.upgrades = {}
            this.score = 0
            this.generateAmount = 0
            this.clicks = 0
            this.totalScore = 0
            this.generatorData = {}
            this.boughtUpgrades = 0
            this.lastOnline = Math.floor(Date.now() / 1000);
            this.achievements = {
                "idkJustRandomPlaceHolder" : [false, "", false],
            }
            if (!window._genIntervalSet) {
                window._genIntervalSet = true
                setInterval(() => this.generateScore(), 1000);
            }
            if (!window._saveIntervalSet) {
                window._saveIntervalSet = true
                setInterval(() => this.saveGame(), 2500);
            }
        }

    }

    collectOffline = () => {
        this.score += this.offlineAmount;
        this.offlineAmount = 0;
    }

    calcOfflineEarn = () => {
        let currentTime = Math.floor(Date.now() / 1000);
        let timeDiff = currentTime - this.lastOnline;
        if (timeDiff > 3600) { //1 hour I think
            if (timeDiff > 115200) {
                timeDiff = 115200;
            }
            const multiplier = .3
            const amount = (this.generateAmount * timeDiff) * multiplier
            this.offlineAmount = amount
            window.showOfflineEarning(amount);
            this.lastOnline = Math.floor(Date.now() / 1000);
        }
    }

    cheat = () => {
        this.clicks = 6000
        this.score = 9000
    }

    get clicks() {
        return this._clicks
    }

    set clicks(newval) {
        this._clicks = parseInt(newval,10)
        if (this.firstLoadClicks) {this.firstLoadClicks=false;return}
        //Game upgrades
        if (this.clicks >= 10 && !this.milestones["achieved10Clicks"]) {
            this.milestones["achieved10Clicks"] = true
            window.clicks10()
        }
        if (this.clicks >= 50 && !this.milestones["achieved50Clicks"]) {
            this.milestones["achieved50Clicks"] = true
            window.clicks50()
        }
        if (this.clicks >= 100 && !this.milestones["achieved100Clicks"]) {
            this.milestones["achieved100Clicks"] = true
            window.clicks100()
        }
        if (this.clicks >= 225 && !this.milestones["achieved225Clicks"]) {
            this.milestones["achieved225Clicks"] = true
            window.clicks225()
        }
        if (this.clicks >= 350 && !this.milestones["achieved350Clicks"]) {
            this.milestones["achieved350Clicks"] = true
            window.clicks350()
        }
        if (this.clicks >= 500 && !this.milestones["achieved500Clicks"]) {
            this.milestones["achieved500Clicks"] = true
            window.clicks500()
        }
        if (this.clicks >= 1250 && !this.milestones["achieved1250Clicks"]) {
            this.milestones["achieved1250Clicks"] = true
            window.clicks1250()
        }


        //Achievements
        if (this.clicks >= 1 && !this.achievements["firstClick"]) {
            this.achievements["firstClick"] = [true, "Click for the first time!", false]
            window.displayAchievement('Getting started!', false)
        }
    }

    get score() {
        return this._score;
    }

    set score(newval) {
        this._score = parseInt(newval,10)
        if (this.firstLoadScore) {this.firstLoadScore=false;return}
        this.totalScore += newval
        if (this.score >= 150 && !this.milestones["achieved150Score"]) {
            this.milestones["achieved150Score"] = true
            window.score150()
        }
        if (this.score >= 500 && !this.milestones["achieved500Score"]) {
            this.milestones["achieved500Score"] = true
            window.score500()
        }
        if (this.score >= 800 && !this.milestones["achieved800Score"]) {
            this.milestones["achieved800Score"] = true
            window.score800()
        }
        if (this.score >= 1200 && !this.milestones["achieved1200Score"]) {
            this.milestones["achieved1200Score"] = true
            window.score1200()
        }
        if (this.score >= 2300 && !this.milestones["achieved2300Score"]) {
            this.milestones["achieved2300Score"] = true
            window.score2300()
        }
        if (this.score >= 3500 && !this.milestones["achieved3500Score"]) {
            this.milestones["achieved3500Score"] = true
            window.score3500()
        }
        
    }

    get generateAmount() {
        return this._generateAmount
    }

    set generateAmount(newval) {
        this._generateAmount = newval
        if (this._generateAmount >= 100 && !this.achievements["100GenerateClicks"]) {
            this.achievements["100GenerateClicks"] = [true, "Generate 100 clicks a second", false]
            window.displayAchievement('Generational Wealth', false)
        }
        if (this._generateAmount >= 2500 && !this.achievements["2500GenerateClicks"]) {
            this.achievements["2500GenerateClicks"] = [true, "Generate 2500 clicks a second", false]
            window.displayAchievement('ITS OVER 2000!', false)
        }
        if (this._generateAmount >= 6700 && !this.achievements["6700GenerateClicks"]) {
            this.achievements["6700GenerateClicks"] = [true, "Generate 6700 clicks a second", true]
            window.displayAchievement('67 (00) MUSTARDDD', true)
        } 
    }

    purchaseUpgrade = (upgrade, el) => {
        if (this.score >= parseInt(this.upgrades[upgrade][0],10)) {
            this.upgrades[upgrade][1] = true
            this.score -= parseInt(this.upgrades[upgrade][0],10)
            this.boughtUpgrades += 1

            if (this.boughtUpgrades >= 5 && !this.achievements["5upgrades"]) {
                this.achievements["5upgrades"] = [true, "Purchase 5 upgrades", false]
                window.displayAchievement('Getting up there', false)
            }

            activeUpgrades.shift()
            
            removeHover(el)
            destroy(el)
            
            if (storedUpgrades.length >= 1) {
                addUpgrade(storedUpgrades[0][0], storedUpgrades[0][1], storedUpgrades[0][2], true)
                storedUpgrades.shift()
            }
            
            loadUpgrades()
            purchaseUpgradeSFX.play()
            
            if (storedUpgrades.length == 0) {
                nextUpgrade.enabled = false
            } else {
                nextUpgrade.enabled = true
            }
            return true
        } else {
            purchaseUpgradeFailSFX.play()
            return false
        }
    }

    buyGen(gen, genPrice, genEarn, genName) {
        if (this.score >= genPrice) {
            //Success
            this.score -= genPrice;

            const newPrice = Math.floor(genPrice * 1.25);
            gen.cost = newPrice;

            this.generateAmount += genEarn;

            if (!this.generatorData[genName]) {
                this.generatorData[genName] = [0, 0, 0]; // [amount bought, current price, total earn]
            }
            this.generatorData[genName][0] += 1; // amount bought
            this.generatorData[genName][1] = newPrice; // store updated price
            this.generatorData[genName][2] += genEarn; // cumulative earn per second contributed

            gen.text = `Generate ${formatNumber(genEarn)} clicks a second\nCost: ${formatNumber(newPrice)} clicks`;
            return true;
        } else {
            print("Broke boy");
            //Failure sound effect
            return false;
        }
    }

    addScore = (newScore) => {
        this.score += newScore
    }

    generateScore = () => {
        this.addScore(this.generateAmount)
    }

    saveGame = () => {
        const save = {
            "score": this.score,
            "generateAmount": this.generateAmount,
            "clicks" : this.clicks,
            "milestones" : this.milestones,
            "upgrades" : this.upgrades,
            "totalScore" : this.totalScore,
            "generatorData" : this.generatorData,
            "saveVersion" : this.saveVersion,
            "achievements" : this.achievements,
            "boughtUpgrades" : this.boughtUpgrades,
            "lastOnline" : Date.now(),
        }
        localStorage.setItem('gameData', JSON.stringify(save))
    }
}

const data = localStorage.getItem('gameData') || null


function onEnter(el, description, cost, event) {
    mouseTooltip.text = description + "\n<center>Cost: " + formatNumber(cost) + "</center>";
    mouseTooltip.enabled = true;
}

function onLeave(event) {
	mouseTooltip.text = "";
	mouseTooltip.enabled = false;
}

function addHover(el, description, cost) {
	console.log("Added hover");

    el._boundEnter = onEnter.bind(null, el, description, cost);
	el._boundLeave = onLeave.bind(null);

	el.addEventListener('mouseenter', el._boundEnter);
	el.addEventListener('mouseleave', el._boundLeave);
}

function removeHover(el) {
	mouseTooltip.text = "";
	mouseTooltip.enabled = false;

	if (el._boundEnter) {
		el.removeEventListener('mouseenter', el._boundEnter);
		delete el._boundEnter;
	}

	if (el._boundLeave) {
		el.removeEventListener('mouseleave', el._boundLeave);
		delete el._boundLeave;
	}
}

function getPerformance() {
    return performance.now()
}

function getDelta() {
    const now = getPerformance()
    const deltaSeconds = (now - lastTime) / 1000
    lastTime = now
    return deltaSeconds
}

function getDeltaCombo() {
    const now = getPerformance()
    const deltaSeconds = (now - lastTime) / 1000
    lastTimeCombo = now
    return deltaSeconds
}

function randomInt(min, max) {
	if (typeof min !== "number" || typeof max !== "number") {
		throw new Error("Both min and max must be numbers");
	}
	if (min > max) {
		throw new Error("Min cannot be greater than max");
	}

	return Math.floor(Math.random() * (max - min + 1)) + min;
}

</script>
<script src="/taptapir/taptapir.js"></script>
<script src="/taptapir/sunsnake_compiler.js">
</script>
<script>
document.addEventListener('DOMContentLoaded', async () => {
    fetch('/main.sunsnake')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.text();
        })
        .then(data => {
            compiled_code = compile(data);
            const run = new Function(compiled_code);
            run();
        })
        .catch(error => {
            console.error('There has been a problem with your fetch operation:', error);
        });
})
</script>
</body>